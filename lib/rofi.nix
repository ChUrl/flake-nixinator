{
  inputs,
  pkgs,
  lib,
  ...
}: rec {
  # Receives attrs like:
  # {
  #   "Poweroff" = "poweroff";
  #   "Reload Hyprland" = "hyprctl reload";
  # }
  mkSimpleMenu = let
    # Makes a string like ''"Poweroff" "Reload Hyprland"''
    unpack-options = attrs: "\"${lib.concatStringsSep "\" \"" (builtins.attrNames attrs)}\"";

    mkCase = option: action: "else if test \"${option}\" = $OPTION\n    set ACTION \"${action}\"";

    cases = attrs:
      lib.pipe attrs [
        (builtins.mapAttrs mkCase)
        builtins.attrValues
        (builtins.concatStringsSep "\n")
      ];
  in
    prompt: attrs:
      pkgs.writeScript "rofi-menu-${prompt}" ''
        #! ${pkgs.fish}/bin/fish

        # OPTIONS contains all possible values Rofi will display
        set OPTIONS ${unpack-options attrs}

        # We choose a single OPTION using Rofi
        set OPTION (echo -e (string join "\n" $OPTIONS) | rofi -dmenu -p " ${prompt} " -i)

        # Check if the chosen OPTION is a valid choice from OPTIONS
        if not contains $OPTION $OPTIONS
            exit
        end

        # Set a command to execute based on the chosen OPTION
        if false
            exit # Easier to generate with this
        ${cases attrs}
        else
            exit
        end

        # Execute the command
        eval $ACTION
      '';

  # Receives attrs like:
  # {
  #   optionA = "exa -1 -D ~/Notes/TU";
  #   optionB = "exa -1 -D ~/Notes/TU/$OPTIONA/Lecture | grep \".pdf\"";
  #   commandB = "xdg-open ~/Notes/TU/$OPTIONA/Lecture/$OPTIONB";
  # }
  #
  # Keys:
  # - optionA, optionB   # Command that generates Rofi options:
  #                        exa -1 -D ~/Notes/TU
  #                        cat /etc/rofi-vpns
  # - commandA, commandB # Action to execute after sth. was chosen (mutually excl. with command)
  # - actionsA, actionsB # Configure actions by lookup (mutually excl. with command):
  #                        actionsB = {"status" = "systemctl status..."}
  # - colorA, colorB     # Configure highlighting conditions:
  #                        colorA = {"red" = "systemctl ... | grep ..."};
  #
  # Use $OPTIONA and $OPTIONB to use the options chosen by option<A/B>-command and rofi
  # Use $EVALA and $EVALB to use the outputs generated by command<A/B>
  mkMenu = let
  in
    prompt: attrs: "";
}
